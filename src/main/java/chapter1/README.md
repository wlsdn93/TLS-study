# 키 교환 알고리즘

카이사르 암호화 같이, 암호화와 복호화에 쓰이는 키가 동일한 방식은 미리 해당 키를 교환해둬야만 했다.   

그러나 현대의 인터넷 환경에서, 모든 사용자들과 미리 비밀키를 공유 한다는 것은 불가능했다.

"디피-헬먼 키 교환 알고리즘"은 이러한 한계점을 해결하기 위해 제시되었다. 

해당 알고리즘은 ***"출제자는 문제를 내기 쉽지만, 문제를 푸는 사람은 풀기가 매우 어려운 수학 문제를 이용하는 것"*** 이다.  

그리고 이러한 문제의 대표적인 예가 **소인수분해** 이다.  

출제자는 그저 적당한 두 개의 소수를 선택해서 곱하고, 풀이자에게 이를 소인수분해 하라고 시키는 것이다.

소수의 크기가 작을 때는 어려워보이지 않지만, 두 소수의 크기가 커질수록 난이도는 기하급수적으로 증가한다.  

---
## 디피-헬먼 알고리즘의 기본 원리

두 사람 A 와 B가 비밀통신을 하고자 한다.

1. 우선 공개적으로 사용할 하나의 수를 선택한다. 이를 g 라고 하자.
2. A와 B는 각각 비밀키로 사용 할 서로 다른 임의의 수를 선택한다. 이 들을 각각 sa, sb 라고 하자.
3. A와 B는 공개된 수인 g를 각각의 비밀키로 거듭제곱 해서, 서로에게 전달한다. 이 값들은 공개키에 해당되며 각각 pa, pb 라고 하자.
- pa = g^sa
- pb = g^sb  

4. 서로 전달받은 공개키를 각각의 비밀키로 다시 거듭제곱 하면, A와 B는 동일한 키값인 K를 갖게된다. 
- pa^sb = (g^sa)^sb = K  
- pb^sa = (g^sb)^sa = K  

---

## 나머지를 이용한 계산의 간소화 

매우 큰 수의 거듭제곱한 숫자를 특정 숫자로 나눈 나머지를 구해야 하는 경우, 처음부터 나머지 연산을 이용하면 계산이 훨씬 간단해진다.  

예를 들어 3의 100제곱을 23으로 나눈 나머지를 구해야 한다고 해보자.  

```text
mod 는 나머지 연산을 의미한다. 예를 들어 10 mod 4 는 2 이다.

3^100 mod 23
= (3^4)^25 mod 23
= (23 * 3 + 12)^25 mod 23
= 12^25 mod 23
```
이러한 식이 성립하는 이유는 아래와 같다. 
조금 더 이해하기 쉽도록 작은 숫자로 나머지 연산을 수행해보자.

```text
19의 3제곱을 5로 나눈 나머지를 구한다고 해보자. 
19^3 mod 5 
= (5 * 3 + 4)^3 mod 5
= 4^3 mod 5

(5 * 3 + 4)*(5 * 3 + 4)*(5 * 3 + 4) 이 식을 전개 하면 어떻게 될 까?
고등학교 수학 시간에 암기하는 공식을 떠올려 보자 
(a + b)^3 는 a^3 + 3a^2b + 3ab^2 + b^3 와 같다.
즉 마지막 b^3 을 제외한 나머지 모든 항들은 a로 나누어 떨어진다. 
```

---
## 디피-헬먼 알고리즘

디피-헬먼 알고리즘의 실제 구현은 기본원리에서 설명한 내용과 더불어 나머지 연산을 이용한다.

앨리스와 밥이 공개된 통신망에서 키 교환을 하기위한 절차는 아래와 같다.

1. 앨리스가 소수 p, 그리고 1 부터 p-1 사이의 정수 g를 선택한다.
   - 이 때, 반드시 g는 p의 원시근 이어야 한다.
   - 원시근이란 1을 제외한 p이하의 모든 자연수 중, 그 거듭제곱을 p로 나눈 나머지가 p미만의 자연수로 고르게 나타나는 수를 의미한다.
   - 원시근이 아닌 수를 선택하게 되면, 순환 그룹의 크기가 충분히 크지 못해 패턴을 예측할 수 있게된다. 
   - 예를 들어서 2와 3은 5의 원시근이다.
```text
2 % 5 == 2
4 % 5 == 4
8 % 5 == 3
16 % 5 == 1
32 % 5 == 2
64 % 5 == 4
...

2의 거듭제곱을 5로 나눈 나머지는 5미만의 자연수 (1, 2, 3, 4)로 고르게 나타난다.

3 % 5 == 3
9 % 5 == 4
27 % 5 == 2
81 % 5 == 1
273 % 5 == 3
...    

3의 거듭제곱을 5로 나눈 나머지는 5미만의 자연수 (3, 4, 1, 2)로 고르게 나타난다.

4 % 5 == 4
16 % 5 == 1
64 % 5 == 4
256 % 5 == 1
...

4의 거듭제곱을 5로 나눈 나머지는 (4, 1)로 고르게 나타나지 않는다.
```
2. 앨리스가 임의의 정수 a를 선택한다. 이 값은 앨리스만 알고있는 비밀키에 해당한다.
3. 앨리스는 앞서 g값을 a제곱한 뒤 p로 나눈 나머지 A를 계산한다.
   - A = g^a mod p
4. 앨리스는 A, g, p 값을 밥에게 전달한다. 외부에 공개되므로 공개키에 해당한다.
5. 밥은 임의의 정수 b를 선택한다. 이 값은 밥만 알고있는 비밀키에 해당한다.
6. 밥은 앨리스로부터 전달받은 g, p값을 이용해, g를 b제곱한 뒤 p로 나눈 나머지 B를 계산한다.
   - B = g^b mod p
7. 밥은 B 값을 앨리스에게 전달한다. 외부에 공개되므로 공개키에 해당한다.
8. 앨리스와 밥은 각각 전달받은 B와 A를 본인들의 비밀키로 제곱하고 p로 나눈 나머지를 계산한다.
   - 앨리스 : B^a mod p = (g^b mod p)^a mod p = g^(ba) mod p = K 
   - 밥    : A^b mod p = (g^a mod p)^b mod p = g^(ab) mod p = K
```text
3^100 mod 23 계산을 다시 떠올려보자
3^100 mod 23 = 81^25 mod 23 
             = (23 * 3 + 12)^25 mod 23
             = 12^25 mod 23
즉 81^25 mod 23 는 (81 mod 23)^25 mod 23 을 계산하는 것과 동일하다.
```
9. 앨리스와 밥은 동일한 값인 대칭키 K를 안전하게 공유하게 되었다.

> ### 공격자는 정말 알 수 없을까?
> 공격자가 얻는 정보는 p, g, A(g^a mod p) 와 B(g^b mod p) 이다.  
> 그리고 공격자가 알아내야 할 키값은 g^(ab) mod p 이다.  
> 앞서 원시근에 대해 설명했듯이, 원시근의 거듭제곱을 p로 나눈 나머지는 1 이상 p-1 이하의 모든 자연수 순환하게 된다.   
> 즉, 원시근을 선택함으로서 공개된 p, g, A, B로부터 a, b값을 추론하는 것이 더욱 어려워진다. 
> a, b값을 추론하는 대신 무차별 대입 공격을 하더라도, 일반적으로 아주 큰 소수(2048비트 이상)를 사용하기 때문에, 헌대 컴퓨팅 능력으로는 무차별 대입 공격이 현실적으로 불가능하다.  
> 또한 웹서비스들은 아주 짧은 시간 내에 모든 키 교환을 마쳐야 하기 때문에, 일반적으로 p, g값을 미리 생성해두고 사용한다.       